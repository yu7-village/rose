import { ClientEvent } from './clientEvent';
import { ConnectionFailedEventPayload, OpenServerEventPayload } from './payloadTypes';
import { Event } from './utils/event';
import { Logger } from './utils/logger';
declare const ServerEventType: readonly ["Open", "Acknowledge"];
declare type ServerEventType = (typeof ServerEventType)[number];
export declare type ServerEvent = {
    type: ServerEventType;
    id: string;
    payload: Record<string, unknown> | undefined;
};
export declare type ConnectionState = 'connecting' | 'connected' | 'reconnecting' | 'closed';
export declare type SocketParams = {
    sessionEndpoint: string;
    token: string;
    logger: Logger;
    sdkVersion: string;
    contextId: string;
};
export declare class Socket {
    private _sessionEndpoint;
    private _token;
    private _logger;
    private _sdkVersion;
    private _contextId;
    private _isOpen;
    private _isClosed;
    private _reconnectCount;
    private _ws;
    connectionState: ConnectionState;
    readonly onConnectionStateChanged: Event<ConnectionState>;
    readonly onOpened: Event<OpenServerEventPayload | undefined>;
    readonly onTokenExpired: Event<void>;
    readonly onEventReceived: Event<ServerEvent>;
    readonly onConnectionFailed: Event<ConnectionFailedEventPayload>;
    private _reconnectTimer;
    private _resendClientEvents;
    constructor({ sessionEndpoint, token, logger, sdkVersion, contextId }: SocketParams);
    private _setConnectionState;
    private _connect;
    updateAuthToken(token: string): void;
    reconnect(): void;
    private close;
    destroy(): void;
    send(clientEvent: ClientEvent): Promise<void>;
    resendAfterReconnect(data: ClientEvent): void;
    pushResendClientEventsQueue(data: ClientEvent): void;
    isClosed(): boolean;
    private _messageHandler;
}
export {};
//# sourceMappingURL=socket.d.ts.map